#include <stdint.h>
#include "stm32f407xx.h"


// USART5 APB1 42MHz
// RX - PD2
// TX - C12 -- bu uygulamada sadece tx calÄ±sacak - AF8

// GPIO - AHB1

#define GPIOC_EN		(1U << 2)
#define GPIOD_EN		(1U << 3)

#define UART5_EN 		(1U << 20)
#define CR1_TE			(1U << 3)	// UART Transmit en
#define CR1_UA			(1U << 13)	// UART UART en
#define SR_TXE			(1U << 7)	// UART Transmit data reg empty

#define SYS_FREQ 		16000000
#define APB1_CLK		SYS_FREQ
#define UART_BAUDRATE 	115200

static void uart_set_baudrate(USART_TypeDef *USARTx, uint32_t PeriphClk, uint32_t baudRate);
static uint16_t compute_uart_bd(uint32_t PeriphClk, uint32_t baudRate);

void uart5_tx_init(void);
void uart5_write(uint8_t *ch);

int main() {

	uart5_tx_init();

	while(1) {
		uart5_write('H');
	}

	return 0;
}

void uart5_tx_init(void) {

	// uart gpio -----------------------

	// gpioc clock en
	RCC->AHB1ENR |= GPIOC_EN;
	// set c12 mode to AF mode 10
	GPIOC->MODER &= ~(1U << 24); // 0
	GPIOC->MODER |= (1U << 25);  // 1
	// set c12 af type to uart5_tx   1000
	GPIOC->AFR[2] |= (1U << 19);
	GPIOC->AFR[2] &= ~(1U << 18);
	GPIOC->AFR[2] &= ~(1U << 17);
	GPIOC->AFR[2] &= ~(1U << 16);
	// uart config ----------------------

	// uart clock en
	RCC->APB1ENR |= UART5_EN;
	// baud rate
	uart_set_baudrate(UART5, APB1_CLK, UART_BAUDRATE);
	// transfer direction
	UART5->CR1 = CR1_TE;
	// en uart
	UART5->CR1 |= CR1_UA;
}

void uart5_write(uint8_t *ch) {
	// is transmit data reg empty
	while(!(UART5->SR & SR_TXE)) {}
	// write data to transmit data reg
	UART5->DR = (*ch++ && (uint8_t)0xFF);

}

static void uart_set_baudrate(USART_TypeDef *USARTx, uint32_t PeriphClk, uint32_t baudRate) {
	USARTx->BRR = compute_uart_bd(PeriphClk, baudRate);
}

static uint16_t compute_uart_bd(uint32_t PeriphClk, uint32_t baudRate) {
	return ((PeriphClk + (baudRate / 2U))/baudRate);
}

/*************************************************
* configure system clock to 168 Mhz
* this is only tested on stm32f4 discovery board
*************************************************/
void set_sysclk_to_168(void)
{
	/* Enable HSE (CR: bit 16) */
	RCC->CR |= (1U << 16);
	/* Wait till HSE is ready (CR: bit 17) */
	while(!(RCC->CR & (1 << 17)));

	/* Enable power interface clock (APB1ENR:bit 28) */
	RCC->APB1ENR |= (1 << 28);

	/* set voltage scale to 1 for max frequency (PWR_CR:bit 14)
	 * (0b0) scale 2 for fCLK <= 144 Mhz
	 * (0b1) scale 1 for 144 Mhz < fCLK <= 168 Mhz
	 */
	PWR->CR |= (1 << 14);

	/* set AHB prescaler to /1 (CFGR:bits 7:4) */
	RCC->CFGR |= (0 << 4);
	/* set APB low speed prescaler to /4 (APB1) (CFGR:bits 12:10) */
	RCC->CFGR |= (5 << 10);
	/* set APB high speed prescaler to /2 (APB2) (CFGR:bits 15:13) */
	RCC->CFGR |= (4 << 13);

	/* Set M, N, P and Q PLL dividers
	 * PLLCFGR: bits 5:0 (M), 14:6 (N), 17:16 (P), 27:24 (Q)
	 * Set PLL source to HSE, PLLCFGR: bit 22, 1:HSE, 0:HSI
	 */
	RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |
	               (PLL_Q << 24) | (1 << 22);
	/* Enable the main PLL (CR: bit 24) */
	RCC->CR |= (1 << 24);
	/* Wait till the main PLL is ready (CR: bit 25) */
	while(!(RCC->CR & (1 << 25)));
	/* Configure Flash
	 * prefetch enable (ACR:bit 8)
	 * instruction cache enable (ACR:bit 9)
	 * data cache enable (ACR:bit 10)
	 * set latency to 5 wait states (ARC:bits 2:0)
	 *   see Table 10 on page 80 in RM0090
	 */
	FLASH->ACR = (1 << 8) | (1 << 9) | (1 << 10 ) | (5 << 0);

	/* Select the main PLL as system clock source, (CFGR:bits 1:0)
	 * 0b00 - HSI
	 * 0b01 - HSE
	 * 0b10 - PLL
	 */
	RCC->CFGR &= ~(3U << 0);
	RCC->CFGR |= (2 << 0);
	/* Wait till the main PLL is used as system clock source (CFGR:bits 3:2) */
	while (!(RCC->CFGR & (2U << 2)));

	// update SystemCoreClock variable
	SystemCoreClock = 168000000;
}
