#include <stdint.h>
#include "stm32f407xx.h"

// USART2 (APB1) TX-> PA2  RX-> PA3
#define USART2_EN		(1U << 17)
#define CR1_TE			(1U << 3)	// UART Transmit en
#define CR1_UA			(1U << 13)	// UART UART en
#define SR_TXE			(1U << 6)

// GPIOA (AHB1)
#define GPIOA_EN		(1U << 0)

#define SYS_FREQ 		((uint32_t)16000000)	// internal high speed osc
#define APB1_CLK		SYS_FREQ

#define UART_BAUDRATE 	((uint32_t)115200)

void usart2_tx_init(void);
void usart2_write(uint8_t ch);
void usart2_test(void);

static void uart_set_baudrate(USART_TypeDef *USARTx, uint32_t PeriphClk, uint32_t baudRate);
static uint16_t compute_uart_bd(uint32_t PeriphClk, uint32_t baudRate);

uint8_t RCC_GetSYSCLKSource(void);
void clock_init(void);
void set_clock_168(void);

int main() {

	clock_init();
	set_clock_168();

	usart2_tx_init();


	usart2_test();

	while(1) {
		usart2_write('H');
		for(int i=0; i<10000000; i++);
	}
}


void usart2_tx_init(void) {
		RCC->APB1ENR |= (1 << 17);

	    // enable GPIOA clock, bit 0 on AHB1ENR
	    RCC->AHB1ENR |= (1 << 0);

	    // set pin modes as alternate mode 7 (pins 2 and 3)
	    // USART2 TX and RX pins are PA2 and PA3 respectively
	    GPIOA->MODER &= ~(0xFU << 4); // Reset bits 4:5 for PA2 and 6:7 for PA3
	    GPIOA->MODER |=  (0xAU << 4); // Set   bits 4:5 for PA2 and 6:7 for PA3 to alternate mode (10)

	    // set pin modes as high speed
	    GPIOA->OSPEEDR |= 0x000000A0; // Set pin 2/3 to high speed mode (0b10)

	    // choose AF7 for USART2 in Alternate Function registers
	    GPIOA->AFR[0] |= (0x7 << 8); // for pin A2
	    GPIOA->AFR[0] |= (0x7 << 12); // for pin A3

	    // USART2 word length M, bit 12
	    //USART2->CR1 |= (0 << 12); // 0 - 1,8,n

	    // USART2 parity control, bit 9
	    //USART2->CR1 |= (0 << 9); // 0 - no parity

	    // USART2 TX enable, TE bit 3
	    USART2->CR1 |= (1 << 3);

	    // USART2 rx enable, RE bit 2
	    USART2->CR1 |= (1 << 2);

	    // baud rate = fCK / (8 * (2 - OVER8) * USARTDIV)
	    //   for fCK = 42 Mhz, baud = 115200, OVER8 = 0
	    //   USARTDIV = 42Mhz / 115200 / 16
	    //   = 22.7864 22.8125
	    // we can also look at the table in RM0090
	    //   for 42 Mhz PCLK, OVER8 = 0 and 115.2 KBps baud
	    //   we need to program 22.8125
	    // Fraction : 16*0.8125 = 13 (multiply fraction with 16)
	    // Mantissa : 22
	    // 12-bit mantissa and 4-bit fraction
	    USART2->BRR |= (22 << 4);
	    USART2->BRR |= 13;

	    // enable usart2 - UE, bit 13
	    USART2->CR1 |= (1 << 13);
}

void usart2_write(uint8_t ch) {
	// is transmit data reg empty
	while(!(USART2->SR & SR_TXE)) {}
	// write data to tx data reg
	USART2->DR = (ch && 0xFF);
}

void usart2_test(void) {
	uint8_t msg[] = "DENEME123";
	for (uint32_t i=0; i<sizeof(msg); i++) {
		// send character
	    USART2->DR = msg[i];
	    // wait for transmit complete
	    while(!(USART2->SR & (1 << 6)));
	}
}

static void uart_set_baudrate(USART_TypeDef *USARTx, uint32_t PeriphClk, uint32_t baudRate) {
	USARTx->BRR = compute_uart_bd(PeriphClk, baudRate);
	 //USART2->BRR |= (22 << 4);
	 //USART2->BRR |= 13;
}

static uint16_t compute_uart_bd(uint32_t PeriphClk, uint32_t baudRate) {
	return ((PeriphClk + (baudRate / 2U))/baudRate);
}

uint8_t RCC_GetSYSCLKSource(void)
{
	return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS_Msk));

}

void clock_init(void) {
	RCC->CR |= (1U << 0);
	RCC->CFGR = 0x00000000;
	RCC->CR &= ~((1U << 16) | (1U << 19) | (1U << 24));
	RCC->PLLCFGR = 0x24003010UL;
	RCC->CR &= ~(1U << 18);
	RCC->CIR = 0x00000000UL;
}

void set_clock_168(void) {
	uint8_t PLL_M = 8;
	uint16_t PLL_N = 336;
	uint8_t PLL_P = 2;
	uint8_t PLL_Q = 7;

	RCC->CR |= (1U << 16);
	while(!(RCC->CR & (1 << 17)));
	RCC->APB1ENR |= (1 << 28);
	PWR->CR |= (1 << 14);
	RCC->CFGR |= (0 << 4);
	RCC->CFGR |= (5 << 10);
	RCC->CFGR |= (4 << 13);
	RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) | (PLL_Q << 24) | (1 << 22);
	RCC->CR |= (1 << 24);
	while(!(RCC->CR & (1 << 25)));
	FLASH->ACR = (1 << 8) | (1 << 9) | (1 << 10 ) | (5 << 0);

	RCC->CFGR &= ~(3U << 0);
	RCC->CFGR |= (2 << 0);
	while (!(RCC->CFGR & (2U << 2)));


}
